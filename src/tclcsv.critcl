#
# Copyright (c) 2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file license.terms for license
#

package require critcl 3.1

critcl::buildrequirement {
    package require critcl::class ; # DSL, easy spec of Tcl class/object commands.
}
critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl CSV extension"
critcl::description {
    Implements commands for processing CSV data.
}

critcl::clean_cache
critcl::tcl 8.5

critcl::ccode {
    #include "csv.h"
}

critcl::tsources csv.tcl
critcl::csources csv.c
critcl::cheaders csv.h khash.h

critcl::ccommand ::tclcsv::csv_read csv_read_cmd

critcl::class::define ::tclcsv::reader {
    method_introspection
    insvariable int eof {
        EOF flag
    } {
        instance->eof = 0;
    }
    insvariable parser_t* parser {
        The CSV parser
    } {
        instance->parser = NULL;
    }
    constructor {
        instance->parser = parser_create(interp, objc, objv, NULL);
        if (instance->parser == NULL)
            goto error;
    }
    destructor {
        if (instance->parser) {
            parser_free(instance->parser);
            instance->parser = NULL;
        }
    }
    method eof proc {} int {
        return instance->eof;
        if (instance->parser->state == FINISHED) {
            int n;
            CSV_NOFAIL(Tcl_ListObjLength(interp, instance->parser->rowsObj, &n), TCL_OK);
            if (n == 0)
                return 1;
        }
        return 0;
    }
    method next command {?COUNT?} {
        int nrows, nread;
        parser_t *parser = instance->parser;

        if (objc > 3) {
            Tcl_WrongNumArgs(interp, 2, objv, "?COUNT?");
            return TCL_ERROR;
        }
        nrows = 1;
        if (objc == 3) {
            if (Tcl_GetIntFromObj(interp, objv[2], &nrows) != TCL_OK)
                return TCL_ERROR;
            if (nrows <= 0) {
                Tcl_SetResult(interp, "Invalid row count specified. Must be a positive integer.", TCL_STATIC);
                return TCL_ERROR;
            }
        }

        if (tokenize_nrows(parser, nrows) != 0 || parser->rowsObj == NULL) {
            if (parser->errorObj)
                Tcl_SetObjResult(interp, parser->errorObj);
            else
                Tcl_SetResult(interp, "Error parsing CSV", TCL_STATIC);
            return TCL_ERROR;
        }

        CSV_NOFAIL(Tcl_ListObjLength(interp, parser->rowsObj, &nread), TCL_OK);
        if (nread == 0) {
            instance->eof = 1;
            return TCL_OK; /* Empty result */
        }
        if (objc == 2) {
            /* Return a single row */
            Tcl_Obj *rowObj;
            CSV_NOFAIL(Tcl_ListObjIndex(interp, parser->rowsObj, 0, &rowObj), TCL_OK);
            CSV_ASSERT(rowObj != NULL);
            Tcl_SetObjResult(interp, rowObj);
            CSV_ASSERT(! Tcl_IsShared(parser->rowsObj));
            Tcl_ListObjReplace(interp, parser->rowsObj, 0, 1, 0, NULL);
        } else {
            /* Return nrows rows where nrows might even be 1 */
            if (nread <= nrows) {
                /* Return the whole list as is */
                Tcl_SetObjResult(interp, parser->rowsObj);
                Tcl_DecrRefCount(parser->rowsObj);
                parser->rowsObj = Tcl_NewListObj(0, NULL);
                Tcl_IncrRefCount(parser->rowsObj);
            } else {
                Tcl_Obj **elems;
                Tcl_ListObjGetElements(interp, parser->rowsObj, &nread, &elems);
                Tcl_SetObjResult(interp, Tcl_NewListObj(nrows, elems));
                CSV_ASSERT(! Tcl_IsShared(parser->rowsObj));
                Tcl_ListObjReplace(interp, parser->rowsObj, 0, nrows, 0, NULL);
            }
        }
        return TCL_OK;
    }
}

package provide tclcsv 2.0.2
critcl::load
