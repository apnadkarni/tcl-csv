#
# Copyright (c) 2015, Ashok P. Nadkarni
# All rights reserved.
#
# See the file license.terms for license
#

package require critcl 3.1

critcl::buildrequirement {
    package require critcl::class ; # DSL, easy spec of Tcl class/object commands.
}
critcl::license "Ashok P. Nadkarni"
critcl::summary "Tcl CSV extension"
critcl::description {
    Implements commands for processing CSV data.
}

critcl::clean_cache
critcl::tcl 8.5

critcl::ccode {
    #include "csv.h"
}

critcl::tsources csv.tcl
critcl::csources csv.c
critcl::cheaders csv.h khash.h

critcl::ccommand ::tclcsv::csv_read csv_read_cmd

critcl::class::define ::tclcsv::reader {
    insvariable parser_t* parser {
        The CSV parser
    } {
        instance->parser = NULL;
    }
    constructor {
        instance->parser = parser_create(interp, objc, objv, NULL);
        if (instance->parser == NULL)
            goto error;
    }
    destructor {
        if (instance->parser)
            parser_free(instance->parser);
    }
    method next command {COUNT} {
        int res, nrows;
        parser_t *parser = instance->parser;

        if (objc > 3) {
            Tcl_WrongNumArgs(interp, 2, objv, "?COUNT?");
            return TCL_ERROR;
        }
        nrows = 1;
        if (objc == 3) {
            res = Tcl_GetIntFromObj(interp, objv[2], &nrows);
            if (res != TCL_OK)
                return res;
            if (nrows <= 0) {
                Tcl_SetResult(interp, "Invalid row count specified. Must be a positive integer.", TCL_STATIC);
                return TCL_ERROR;
            }
        }
        res = tokenize_nrows(parser, nrows) == 0 ? TCL_OK : TCL_ERROR;
        if (res == TCL_OK) {
            if (objc == 2) {
                /* Return a single row */
                if (parser->rowsObj) {
                    Tcl_Obj *rowObj;
                    res = Tcl_ListObjIndex(interp, parser->rowsObj, 0, &rowObj);
                    if (res == TCL_OK) {
                        Tcl_SetObjResult(interp, rowObj);
                        Tcl_ListObjReplace(interp, parser->rowsObj, 0, 1, 0, NULL);
                    }
                }
            } else if (parser->rowsObj) {
                /* Return nrows rows where nrows might even be 1 */
                int nread;
                res = Tcl_ListObjLength(interp, parser->rowsObj, &nread);
                if (res == TCL_OK) {
                    if (nread <= nrows) {
                        /* Return the whole list as is */
                        Tcl_SetObjResult(interp, parser->rowsObj);
                        Tcl_DecrRefCount(parser->rowsObj);
                        parser->rowsObj = Tcl_NewListObj(0, NULL);
                        Tcl_IncrRefCount(parser->rowsObj);
                    } else {
                        Tcl_Obj **elems;
                        Tcl_ListObjGetElements(interp, parser->rowsObj, &nread, &elems);
                        Tcl_SetObjResult(interp, Tcl_NewListObj(nrows, elems));
                        Tcl_ListObjReplace(interp, parser->rowsObj, 0, nrows, 0, NULL);
                    }
                }
            }
        } else {
            if (parser->errorObj)
                Tcl_SetObjResult(interp, parser->errorObj);
            else
                Tcl_SetResult(interp, "Error parsing CSV", TCL_STATIC);
        }
        return res;
    }
}

package provide tclcsv 1.0
critcl::load
