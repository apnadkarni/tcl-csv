text {
    ((= chap_tclcsv_ref "The tclcsv extension"))
    :toc: 
    :toclevels: 5
    :toc-title: Content
    :icons:  font
    :sectnums:
    :sectlinks:
    :experimental:
    :linkcss:
    
    ((author "Ashok P. Nadkarni"))
}


text {
    == Introduction

    The `tclcsv` extension for Tcl provides a fast and flexible means of
    reading text files in _Comma Separated Value_ (CSV) format.

    [NOTE]
    The http://tcl.activestate.com/software/tcllib/[tcllib]
    distribution also has a package `csv` that is capable
    of reading and writing CSV files. It has the advantage of being
    a pure Tcl package but conversely has much lower performance which
    is an issue only for larger files. It is also a little less flexible
    in terms of input syntax.
}

text {
    == Downloads and installation

    Prebuilt 32- and 64-bit binaries for Windows are available from
    http://sourceforge.net/projects/tclcsv/files/. Unzip the distribution
    into a directory that is included in your Tcl `auto_path`.
    
    For *ix systems, a TEA-compliant source distribution can be downloaded from
    from the same location. To install, unpack the distribution and
    in the toplevel directory type
} syntax {
    ./configure --with-tcl=__PATH_TO_TCLCONFIG__
    make install
} text {
    where __PATH_TO_TCLCONFIG__ is the full path to the directory
    containing the `tclConfig.sh` file for your Tcl installation.
}

text {
    == General usage

    To use the extension, load it with `package require`:
} script {
    package require tclcsv
} text {

    The package provides two ways to read CSV data from a channel:

    * The ((^ tclcsv_csv_read csv_read))
    command parses CSV data and returns it as a list
    of lists in a single call.
    
    * The ((^ tclcsv_reader reader))
    command which returns a command object which can
    then be used to incrementally return rows from the CSV data.
    
    Both forms take various options that
    indicate the specific dialect of CSV format such as the character
    used for delimiting fields, as well as options that limit which rows
    of the data are returned.

    [TIP]
    ====
    Although the `tclcsv` commands work with channels, not strings,
    it is easy enough to parse CSV data that is contained in a string.
    Use the `tcl::chan::string` package available as part
    of http://tcl.activestate.com/software/tcllib/[tcllib].
    You can load the package as
} shell {
    package require tcl::chan::string
} text {
    and then create channels from string data
    as shown in the examples in this documentation.
    ====

    In addition to the commands for reading CSV data, the package
    provides two convenience commands that are primarily intended
    for interactive use when the format of the CSV data is not known.

    * The ((^ tclcsv_sniff sniff)) command uses heuristics to determine
    the format of the CSV data and returns a list of appropriate options
    required for parsing it with the ((^ tclcsv_csv_read csv_read)) or
    ((^ tclcsv_reader reader)) commands.

    * The ((^ tclcsv_sniff_header sniff_header))
    command uses heuristics to determine the types of the columns
    in the CSV data and whether the data is prefixed with a header line.
}


text {
    == Command reference

    
    All commands are located in the `tclcsv` namespace.

    === Commands

    ((cmddef tclcsv_csv_read "csv_read ?_OPTIONS_? _CHANNEL_"))

    The command reads data from the specified channel
    (which must not be non-blocking) and returns
    a Tcl list each element of which is a list corresponding to
    one row in the read CSV data. The caller should have appropriately
    positioned the channel read pointer and configured its encoding before
    calling this command.

    The command will normally read all data from
    the channel until EOF is encountered and return the corresponding
    rows. The following options modify this behaviour:

    ((.Table tab_tclcsv_rowopts "Options for filtering rows"))
    [cols="20,80"]
    |===

    |`-nrows _NROWS_`
    |If specified, stops after _NROWS_ rows are read. Note however that
    it does not guarantee that the channel read pointer is placed just beyond
    the last read data.

    |`-skipblanklines _BOOLEAN_`
    |If specified as `true` (default), empty lines are ignored. If `false`
    empty lines are treated as rows with no fields.

    |`-skiplines _LINELIST_`
    |If specified, _LINELIST_ must be a list of integer
    line numbers (first line being at position 0). The corresponding lines
    are skipped and not included in the returned data. The line numbering
    includes commented lines if comments are enabled.

    |`-startline _LINENUM_`
    |If specified, the first _LINENUM_ files of input are ignored.
    Note this includes commented lines if comments are enabled.
    
    |===
}

text {

    There are several variations of the CSV format. The following options
    specify what variant is expected.
    
    ((.Table tab_tclcsv_fmtopts "CSV format options"))
    [cols="20,80"]
    |===

    |`-comment _COMMENTCHAR_`
    |Specifies the character to use as a comment leader. All characters
    on a line after _COMMENTCHAR_ are ignored. _COMMENTCHAR_ must
    be an ASCII character. If _COMMENTCHAR_ is
    the empty string (default), comment recognition is disabled.

    |`-delimiter _DELIMCHAR_`
    |Specifies the delimiter character that separates fields. Defaults
    to `,`.

    |`-doublequote _BOOLEAN_`
    |Controls how the quote character inside a field value is treated.
    If specified as `true` (default), quote characters in a field
    are expected to be represented by doubling them. If `false`,
    they are expected to be preceded with an escape character.

    |`-escape _ESCCHAR_`
    |If specified, any character appearing after _ESCCHAR_ is treated
    as an ordinary character with no special meaning. If unspecified
    or specified as an empty string, the escaping mechanism is disabled.
    _ESCCHAR_ must be an ASCII character or an empty string.

    |`-quote _QUOTECHAR_`
    |Specifies the character to use for quoting when a field contains
    special characters such as the delimiter or line terminators.
    Defaults to the double quote character.

    |`-skipleadingspace _BOOLEAN_`
    |If specified as `true`, leading space characters in fields are stripped.
    If `false` (default), it is retained.
    
    |`-terminator _TERMCHAR_`
    |Specifies the character to use to terminate a row. By default,
    each input line is a treated as a row.
    
    |===

    [NOTE]
    The command does not require that all rows have the same number of
    fields. If required, the caller has to check that all returned rows
    have the same number of elements.
}

text {
    ((cmddef tclcsv_reader "reader SUBCOMMAND ?_OPTIONS_?"))

    This command takes one of the two forms shown below.
} syntax {
    reader create _CMDNAME_ ?_OPTIONS_? _CHANNEL_
    reader new ?_OPTIONS_? _CHANNEL_
} text {
    Each form creates a command object that will _incrementally_
    parse CSV data from the specified channel (which must not be non-blocking).
    The caller should have appropriately
    positioned the channel read pointer and configured its encoding before
    calling this command.

    The `reader create` command allows the caller
    to specify the name of this command object whereas `reader new` will
    generate a new unique name. Both return the name of the created command.

    Options are as detailed for the ((^ tclcsv_csv_read csv_read))
    command with the exception of the `-nrows` option which is not relevant
    for this interface.
    
    The methods supported by the reader command objects are detailed below.
    
    ((cmddef tclcsv_reader_destroy "_READER_ destroy" 1))
    Destroys the _READER_ command object. Note that closing the attached
    channel is the caller's responsibility.
    
    ((cmddef tclcsv_reader_eof "_READER_ eof" 1))
    Returns 1 if there are no more rows and 0 otherwise.
    
    ((cmddef tclcsv_reader_next "_READER_ next ?_COUNT_?" 1))
    Returns one or more rows. If _COUNT_ is not specified, the return
    value is a list corresponding to a single row.
    If _COUNT_ is specified, the return value
    is a list of up to _COUNT_ sublists each of which corresponds to a row.
    Fewer than _COUNT_ rows may be returned if that many
    are not available.
    
    Note that `_READER_ next` is _not_ the same as `_READER_ next 1`.
    The former returns a single row, the latter returns a list containing
    a single row.

    When no more rows are available, the method returns an empty list.
    This is not distinguishable from an empty line in the CSV input
    if the `-skipblanklines` option was specified as `false`. The
    ((^ tclcsv_reader_eof eof)) method may be used to distinguish
    the two cases.

    .Example

    The following is an example of parsing using `reader` objects.
} shell {
    set fd [tcl::chan::string { \
        r0c0, r0c1, r0c2
        r1c0, r1c1, r1c2
        r2c0, r2c1, r2c2
        r3c0, r3c1, r3c2
    }]
    set reader [tclcsv::reader new -skipleadingspace 1 $fd]
    $reader next
    $reader next 1; # Note difference in return value from previous command
    $reader next 2
    $reader next
    $reader eof
    $reader destroy
    close $fd
}

text {
    ((cmddef tclcsv_sniff "sniff ?-delimiters _DELIMITERS_? _CHANNEL_"))

    Attempts to guess the format of the data in the channel and returns
    a list of appropriate options to be passed to ((^ tclcsv_csv_read)).
    The command uses heuristics that may not work for all files and
    as such is intended for interactive use.

    The channel must be seekable and the command always returns the
    channel in the same position it was in when the command was called.
    This is true for both normal returns as well as exceptions.

} shell {
    set fd [tcl::chan::string { \
        r0c0, r0c1, r0c2
        r1c0, r1c1, r1c2
        r2c0, r2c1, r2c2
    }]
    set opts [tclcsv::sniff $fd]
    tclcsv::csv_read {*}$opts $fd
    close $fd
} shell {
    set fd [tcl::chan::string { \
        'r0;c0';'r0c1';'r0c2'
        'r1c0'; 'r1c1'; 'r1c2'
        'r2c0'; 'r2c1'; 'r2c2'
    }]
    set opts [tclcsv::sniff $fd]
    tclcsv::csv_read {*}$opts $fd
    close $fd
}
    
text {
    ((cmddef tclcsv_sniff_header "sniff_header ?_OPTIONS_? _CHANNEL_"))

    Attempts to guess whether the CSV data contained in the channel
    includes a header. It also attempts to guess the type of the data
    in each column of the CSV file. _OPTIONS_ specify the CSV dialect
    of the data. See ((^ tab_tclcsv_fmtopts)).

    If the data includes a header, the command returns a list with two
    elements, the first of which is a list containing the deduced type
    of each column, and the second element being a list containing
    the header fields for each column. If the command deduces that
    the data does not contain a header, the returned list does not
    contain the second element.

    The deduced type of each column is one of `integer`, `real` or
    `string`. Note that `integer` type check is done as a decimal
    string and thus hexadecimal values are treated as strings
    and values like `08` (invalid octal) are  accepted as valid
    integer values.
    
    The command uses heuristics that may not work for all files and
    as such is intended for interactive use.

    The channel must be seekable and the command always returns the
    channel in the same position it was in when the command was called.
    This is true for both normal returns as well as exceptions.

    The following examples show the return values with or without
    a header being present.
} shell {
    set fd [tcl::chan::string { \
        City, Longitude, Latitude
        New York, 40.7127, 74.0059
        London, 51.5072, 0.1275
    }]
    tclcsv::sniff_header $fd
    close $fd
    
    set fd [tcl::chan::string { \
        New York, 40.7127, 74.0059
        London, 51.5072, 0.1275
    }]
    tclcsv::sniff_header $fd
    close $fd
} text {
    Note that when a header is present, you can use the `-skiplines` option
    to ((^ tclcsv_csv_read csv_read)) to skip the header.
}

text {
    == Source code

    The source code for the extensions is available from its project
    page at http://sourceforge.net/projects/tclcsv/.
}

text {
    == Reporting bugs

    Please report any bugs at http://sourceforge.net/p/tclcsv/tickets/.
}

text {
    == License

    See the file `license.terms` in the distribution or in the
    `src` directory in the source repository.
}

text {
    == Acknowledgements

    The core of the CSV parsing code is adapted from the CSV parser
    implemented by the Python http://pandas.pydata.org[pandas] library.

    The hashing code is from https://github.com/attractivechaos/klib[attractivechaos].
}
